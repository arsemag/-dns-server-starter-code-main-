#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from dnslib import DNSRecord, DNSHeader, RR, QTYPE, A, dns
from io import StringIO

class Server:
    def __init__(self, root_ip, domain, port):
        self.root_ip = root_ip
        self.domain = domain

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]

        self.log("Bound to port %d" % self.port)

        self.records = {}
        self.auth_domain = None
        self.pending = {}  # Maps forward_sock -> (client_request, addr, original_query, timestamp)
        self.parse_zone_file(domain)

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send(self, addr, message):
        self.log("Sending message:\n%s" % message)
        self.socket.sendto(message.pack(), addr)

    def parse_zone_file(self, file_path):
        with open(file_path, 'r') as f:
            zone_text = f.read()
        for rr in RR.fromZone(zone_text):
            if rr.rtype == QTYPE.SOA:
                self.auth_domain = str(rr.rname)
                self.log("Found SOA record for domain: %s" % self.auth_domain)
            name = str(rr.rname)
            if name in self.records:
                self.records[name].append(rr)
            else:
                self.records[name] = [rr]

    def send_forward_request(self, query, client_addr):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.setblocking(False)
        try:
            sock.sendto(query.pack(), (self.root_ip, 60053))
            self.pending[sock] = (query, client_addr, query, time.time())
        except Exception as e:
            self.log(f"Error sending forward request: {e}")
            sock.close()

    def handle_forward_response(self, sock):
        try:
            data, _ = sock.recvfrom(65535)
            response = DNSRecord.parse(data)
            query, addr, original_query, _ = self.pending[sock]
            response.header.aa = 0
            response.header.ra = 1
            self.send(addr, response)
        except Exception as e:
            self.log(f"Error handling forward response: {e}")
        finally:
            sock.close()
            del self.pending[sock]

    def recv(self, socket):
        data, addr = socket.recvfrom(65535)
        request = DNSRecord.parse(data)
        self.log("Received message:\n%s" % request)

        qname = str(request.q.qname)
        qtype = QTYPE[request.q.qtype]

        response = request.reply()
        if qname in self.records:
            for rr in self.records[qname]:
                if QTYPE[rr.rtype] == qtype or qtype == "ANY":
                    response.add_answer(rr)
                    if QTYPE[rr.rtype] == "NS":
                        self.ns_case(rr, response)
                elif QTYPE[rr.rtype] == "CNAME":
                    self.cname_case(rr, response)
        else:
            if self.auth_domain and qname.endswith(self.auth_domain):
                response.header.rcode = 3
                response.header.ra = 1
                if self.auth_domain in self.records:
                    for rr in self.records[self.auth_domain]:
                        response.add_auth(rr)
                self.send(addr, response)
            else:
                self.send_forward_request(request, addr)

    def ns_case(self, record, response):
        ns_target = str(record.rdata)
        if ns_target in self.records:
            response.add_auth(record)
            for r in self.records[ns_target]:
                if QTYPE[r.rtype] == "A":
                    response.add_ar(r)

    def cname_case(self, record, response):
        response.add_answer(record)
        cname_target = str(record.rdata)
        if cname_target in self.records:
            for a_rr in self.records[cname_target]:
                if a_rr.rtype == QTYPE.A:
                    response.add_answer(a_rr)

    def run(self):
        while True:
            read_socks = [self.socket] + list(self.pending.keys())
            ready_socks, _, _ = select.select(read_socks, [], [], 0.1)

            for sock in ready_socks:
                if sock == self.socket:
                    self.recv(sock)
                elif sock in self.pending:
                    self.handle_forward_response(sock)

            now = time.time()
            for sock in list(self.pending.keys()):
                _, _, _, timestamp = self.pending[sock]
                if now - timestamp > 3:
                    self.log("Timeout on socket, cleaning up")
                    sock.close()
                    del self.pending[sock]

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('root_ip', type=str, help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int, help="The port this server should bind to", default=0)
    args = parser.parse_args()
    sender = Server(args.root_ip, args.zone, args.port)
    sender.run()
