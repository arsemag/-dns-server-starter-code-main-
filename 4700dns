#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from pydoc import resolve


from dnslib import DNSRecord, DNSHeader, RR, QTYPE, A, dns, DNSQuestion
import dns.resolver
from io import StringIO


class Server:
    def __init__(self, root_ip, domain, port):
        self.root_ip = root_ip
        self.domain = domain

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]

        self.log("Bound to port %d" % self.port)

        self.list_of_sockets = []
        self.list_of_sockets.append(self.socket)

        self.client_to_request = {} ### client : request
        self.socket_to_addr = {} ## socket : ip add

        self.records = {}  # Add this before calling parse_zone_file
        self.auth_domain = None
        self.parse_zone_file(domain)

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send(self, addr, message, sock):
        self.log("Sending message:\n%s" % message)
        sock.sendto(message.pack(), addr)

    def parse_zone_file(self, file_path):
        with open(file_path, 'r') as f:
            zone_text = f.read()
        for rr in RR.fromZone(zone_text):
            # Check if this is the SOA record
            if rr.rtype == QTYPE.SOA:
                # Store the domain (rname) from the SOA record as the authoritative domain
                self.auth_domain = str(rr.rname)
                self.log("Found SOA record for domain: %s" % self.auth_domain)
            # Add the record to the records dictionary
            name = str(rr.rname)
            if name in self.records:
                self.records[name].append(rr)
            else:
                self.records[name] = [rr]

    # def forward_helper(self, client_request, ip):
    #     forward_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    #     forward_sock.settimeout(2)
    #
    #     try:
    #         forward_sock.sendto(client_request.pack(), (ip, 60053))
    #         data, addr = forward_sock.recvfrom(65535)
    #         forward_response = DNSRecord.parse(data)
    #         return forward_response
    #     except Exception as e:
    #         print(f"Error during DNS forwarding: {e}", file=sys.stderr)
    #         return None
    #     finally:
    #         forward_sock.close()

    def forward_request(self, client_request, ip, response, sock,  depth=0):
        if depth > 10:  # prevent recurising too much
            return None


        if response is None:
            return None

        # If we got an answer, return it
        if response.rr:
            response.header.aa = 0
            response.header.ra = 1
            return response

        # Look for NS records in authority section
        ns_records = response.auth
        next_ip = None

        # First try to find A records in additional section
        for rr in response.ar:
            if rr.rtype == QTYPE.A:
                next_ip = str(rr.rdata)
                break

        # If no A records found, query for NS records
        if not next_ip and ns_records:
            for ns in ns_records:
                if QTYPE[ns.rtype] == "NS":
                    ns_domain = str(ns.rdata)
                    # Create a new query for the NS domain's A record
                    ns_query = DNSRecord.question(ns_domain, QTYPE.A)
                    self.send(ip, ns_query, sock)
                    ns_response = ns_query.reply()
                    if ns_response and ns_response.rr:
                        for rr in ns_response.rr:
                            if rr.rtype == QTYPE.A:
                                next_ip = str(rr.rdata)
                                break
                        if next_ip:
                            break

        if next_ip:
            # Recursively query the next nameserver
            self.forward_request(client_request, next_ip, sock, depth + 1)

        # If we get here, we couldn't find an answer
        response.header.aa = 0
        response.header.ra = 1
        return response


    def recv(self, sock):
            data, addr = sock.recvfrom(65535)
            request = DNSRecord.parse(data)
            self.log("Received message:\n%s" % request)

            qname = str(request.q.qname)
            qtype = QTYPE[request.q.qtype]

            response = request.reply()
            if qname in self.records:
                for rr in self.records[qname]:
                    if QTYPE[rr.rtype] == qtype or qtype == "ANY":
                        response.add_answer(rr)
                        if QTYPE[rr.rtype] == "NS":
                           self.ns_case(rr, response)
                    elif QTYPE[rr.rtype] == "CNAME":
                        self.cname_case(rr, response)
            else:
                if qname.endswith(self.auth_domain):
                    response.header.rcode = 3
                    if self.auth_domain in self.records:
                        for rr in self.records[self.auth_domain]:
                            response.add_auth(rr)

                else:
                    new_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                    new_socket.bind(("0.0.0.0", 0))
                    self.list_of_sockets.append(new_socket)

                    domain_name = qname.split(".")
                    domain_name = [part + "." for part in domain_name]
                    last = domain_name.pop()


                    question = DNSRecord(q=DNSQuestion(last, QTYPE.NS))
                    response = question.reply()

                    self.client_to_request[addr] = request
                    self.socket_to_addr[new_socket] = addr

                    self.send((self.root_ip, 53), question, new_socket)
                    print("sent to root server")

            self.send(addr, response, self.socket) #TODO: check if this is correct

    def ns_case(self, record, response):
        # print("this is we got her")
        ns_target = str(record.rdata)
        if ns_target in self.records:
            response.add_auth(record)
            for r in self.records[ns_target]:
                if QTYPE[r.rtype] == "A":
                    print("got here")
                    response.add_ar(r)

    def cname_case(self, record, response):
        response.add_answer(record)
        cname_target = str(record.rdata)
        if cname_target in self.records:
            for a_rr in self.records[cname_target]:
                if a_rr.rtype == QTYPE.A:
                    response.add_answer(a_rr)

    def send_outside_zone(self, sock):
        data, addr = sock.recvfrom(65535)
        request = DNSRecord.parse(data)
        self.log("Received message outside zone:\n%s" % request)

        response = request.reply()
        print(f"this is the response {response}")
        forward_response = self.forward_request(request, self.root_ip, response, sock)

        # print(f"got this response: {forward_response}")
        if forward_response:
            print(f"sending forward_response {forward_response} and this is the addr {addr}") # so it is sending a the foward response
            self.send(addr, forward_response, sock)
        else:
            print("FAILED")
            response.header.rcode = 2  # SERVER FAIL
            self.send(addr, response, sock)


    ## get the response and give back to the client
    def in_zone(self, name):
        return name == self.auth_domain

    def run(self):
        seq = 0
        while True:
            socks = select.select(self.list_of_sockets, [], [], 0.1)[0]
            print(f"this is the socks {socks}")
            for conn in socks:

                if self.socket_to_addr.get(conn) is None:
                        self.recv(conn)
                else:
                    print("GOT TO OUTSIDE ZONE")
                    self.send_outside_zone(conn)


        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('root_ip', type=str, help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int, help="The port this server should bind to", default=0)
    args = parser.parse_args()
    sender = Server(args.root_ip, args.zone, args.port)
    sender.run()